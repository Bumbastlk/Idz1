New chat
JS Usage Tips


MySQL запросы.
MySQL запросы.
JS Syntax Help
JavaScript question answered.
JavaScript клітинний автомат.
JavaScript Examples
Snake Game in JavaScript.
JavaScript сценарії створення.
JS сценарії - створення.
Конфігурація мережевих засобів.
ASCII Cat Drawing.
Атилла - вождь гуннов.
Clear conversations
My plan
Settings
Get help
Log out
Model: GPT-4

Данііл Карась
JavaScript
JavaScript is a versatile, high




Данііл Карась
Write code for Breakout in JavaScript with usage of canvas.
Breakout begins with eight rows of bricks, with two rows each of a different color. The color order from the bottom up is yellow, green, orange and red. Using a single ball, the player must knock down as many bricks as possible by using the walls and/or the paddle below to hit the ball against the bricks and eliminate them.
Creating a complete Breakout game is quite lengthy, so I'll provide you with a simplified version that you can build upon. Here's a basic implementation of the Breakout game using JavaScript and the HTML5 <canvas> element:

html
Copy code
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout</title>
    <style>
        canvas {
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="480" height="320"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const ballRadius = 10;
        const paddleHeight = 10;
        const paddleWidth = 75;
        let paddleX = (canvas.width - paddleWidth) / 2;

        let x = canvas.width / 2;
        let y = canvas.height - 30;
        let dx = 2;
        let dy = -2;

        const brickRowCount = 8;
        const brickColumnCount = 2;
        const brickWidth = 75;
        const brickHeight = 20;
        const brickPadding = 10;
        const brickOffsetTop = 30;
        const brickOffsetLeft = 30;

        const bricks = [];
        for (let c = 0; c < brickColumnCount; c++) {
            bricks[c] = [];
            for (let r = 0; r < brickRowCount; r++) {
                bricks[c][r] = { x: 0, y: 0, status: 1 };
            }
        }

        let rightPressed = false;
        let leftPressed = false;

        document.addEventListener('keydown', keyDownHandler);
        document.addEventListener('keyup', keyUpHandler);

        function keyDownHandler(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                rightPressed = true;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                leftPressed = true;
            }
        }

        function keyUpHandler(e) {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                rightPressed = false;
            } else if (e.key === 'Left' || e.key === 'ArrowLeft') {
                leftPressed = false;
            }
        }

        function drawBall() {
            ctx.beginPath();
            ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = 'red';
            ctx.fill();
            ctx.closePath();
        }

        function drawPaddle() {
            ctx.beginPath();
            ctx.rect(paddleX, canvas.height - paddleHeight, paddleWidth, paddleHeight);
            ctx.fillStyle = 'green';
            ctx.fill();
            ctx.closePath();
        }

        function drawBricks() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    if (bricks[c][r].status === 1) {
                        let brickX = (r * (brickWidth + brickPadding)) + brickOffsetLeft;
                        let brickY = (c * (brickHeight + brickPadding)) + brickOffsetTop;
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;
                        ctx.beginPath();
                        ctx.rect(brickX, brickY, brickWidth, brickHeight);
                       



Данііл Карась
Continue  from "ctx.rect(brickX, brickY, brickWidth, brickHeight);
Continuing from "ctx.rect(brickX, brickY, brickWidth, brickHeight);":

javascript
Copy code
                        ctx.fillStyle = c % 2 === 0 ? 'yellow' : 'green';
                        ctx.fill();
                        ctx.closePath();
                    }
                }
            }
        }

        function collisionDetection() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const brick = bricks[c][r];
                    if (brick.status === 1) {
                        if (x > brick.x && x < brick.x + brickWidth && y > brick.y && y < brick.y + brickHeight) {
                            dy = -dy;
                            brick.status = 0;
                        }
                    }
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBall();
            drawPaddle();
            drawBricks();
            collisionDetection();

            if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
                dx = -dx;
            }
            if (y + dy < ballRadius) {
                dy = -dy;
            } else if (y + dy > canvas.height - ballRadius) {
                if (x > paddleX && x < paddleX + paddleWidth) {
                    dy = -dy;
                } else {
                    alert('GAME OVER');
                    document.location.reload();
                    clearInterval(interval);
                }
            }

            if (rightPressed && paddleX < canvas.width - paddleWidth) {
                paddleX += 7;
            } else if (leftPressed && paddleX > 0) {
                paddleX -= 7;
            }

            x += dx;
            y += dy;
        }

        const interval = setInterval(draw, 10);
    </script>
</body>
</html>
This code continues the drawing of bricks, adds collision detection, and implements the game loop using setInterval. The colors are alternating between yellow and green for simplicity, but you can easily modify the colors based on the desired order (yellow, green, orange, red) by changing the ctx.fillStyle line in the drawBricks function.




Regenerate response
a

ChatGPT Mar 23 Version. ChatGPT may produce inaccurate information about people, places, or facts.
New chat
